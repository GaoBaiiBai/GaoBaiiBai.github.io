<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python高级编程基础（四）</title>
    <url>/2020/05/10/python-seniorbasic4/</url>
    <content><![CDATA[<p>好久没有更新个人的博客了，经过这几天的学习，对于Python的基础又有了新的认知，所以将要从以下几个方面来介绍-多线程、多进程和线程池编程-协程和异步io-asyncio并发编程这几个方面来介绍。</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>Python - 高级编程 - 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级编程基础（三）</title>
    <url>/2020/05/09/python-seniorbasic3/</url>
    <content><![CDATA[<p>好久没有更新个人的博客了，经过这几天的学习，对于Python的基础又有了新的认知，所以将要从以下几个方面来介绍-对象引用、可变性和垃圾回收-元类编程-迭代器和生成器这几个方面来介绍。</p>
<a id="more"></a>

<p><strong>1. 可变性和垃圾回收</strong><br><strong>对象引用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python和Java中的变量本质不一样,Python的变量实质上一个指针</span></span><br><span class="line"><span class="comment"># 先生成对象再把指针指向值</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">print(a==b)</span><br><span class="line">print(id(a),id(b))</span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br></pre></td></tr></table></figure>

<p><strong>垃圾回收</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python中垃圾回收的算法是采用：引用计算</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b =a</span><br><span class="line"><span class="comment"># 再del的过程中是减少对象上的计数，当数据降为1的时候就直接回收掉了</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">a = object()</span><br><span class="line">b = a</span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="comment"># 删除了a因为最先计数，b还是可以打印的</span></span><br><span class="line">print(b)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p><strong>Python中的一个经典错误</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    a += b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="comment"># 尽力不要传递list与dict是会被改变的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, staffs=[])</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.staffs = staffs</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, staff_name)</span>:</span></span><br><span class="line">        self.staffs.append(staff_name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, staff_name)</span>:</span></span><br><span class="line">        self.staffs.remove(staff_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 因为列表赋值为空，同时并没有传入列表，所以公用了一个staffs，</span></span><br><span class="line">    <span class="comment"># 因此后面的值会重复前面的值，造成了冲突</span></span><br><span class="line">    com1 = Company(<span class="string">"com1"</span>, [<span class="string">"bobby1"</span>, <span class="string">"bobby2"</span>])</span><br><span class="line">    com1.add(<span class="string">"bobby3"</span>)</span><br><span class="line">    com1.remove(<span class="string">"bobby1"</span>)</span><br><span class="line">    <span class="keyword">print</span> (com1.staffs)</span><br><span class="line"></span><br><span class="line">    com2 = Company(<span class="string">"com2"</span>)</span><br><span class="line">    com2.add(<span class="string">"bobby"</span>)</span><br><span class="line">    print(com2.staffs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (Company.__init__.__defaults__)</span><br><span class="line"></span><br><span class="line">    com3 = Company(<span class="string">"com3"</span>)</span><br><span class="line">    com3.add(<span class="string">"bobby5"</span>)</span><br><span class="line">    <span class="keyword">print</span> (com2.staffs)</span><br><span class="line">    <span class="keyword">print</span> (com3.staffs)</span><br><span class="line">    <span class="keyword">print</span> (com2.staffs <span class="keyword">is</span> com3.staffs)</span><br><span class="line">    print(id(com2))</span><br><span class="line">    print(id(com3))</span><br></pre></td></tr></table></figure>
<p>在Python中如果原先顶的是列表可变变量的话，多次调用会使得系统默认是同一个对象，就会在原来的基础上进行操作，所以为了解决这个问题，我们在操作的时候要传入不可变的变量以解决问题。</p>
<p><strong>2. 元类编程</strong><br><strong>property动态属性</strong>:当我们需要动态的修改某一个属性值的时候我们可以使用@property方法，定义类方法的名称来调用函数的值，同时可以通过定义的方法来设置值例如：@age.setter，这时候我们只要调用_age这个私有属性就可以获取值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  datetime <span class="keyword">import</span> date,datetime</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthady = birthday</span><br><span class="line">        self._age=<span class="number">0</span></span><br><span class="line">    <span class="comment"># def get_age(self):</span></span><br><span class="line">    <span class="comment">#     return datetime.now().year -self.birthady.year</span></span><br><span class="line">    <span class="comment"># 属性描述值，直接可以使用age的值了</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().year - self.birthady.year</span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        self._age =value</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User(<span class="string">"GYQ"</span>,date(year=<span class="number">1999</span>,month=<span class="number">7</span>,day=<span class="number">21</span>))</span><br><span class="line">    user.age=<span class="number">30</span></span><br><span class="line">    print(user._age)</span><br><span class="line">    print(user.age)</span><br></pre></td></tr></table></figure>

<p><strong><strong>getattr</strong>和<strong>getattribute</strong>的区别</strong>:<strong>getattr</strong>就是在查找不到的时候调用，当找不到类属性值的时候会进入这里面查找，而<strong>getattribute</strong>则是不管存不存在都会进去查找属性值，如下列代码，返回的company_name值就为gYQ。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  datetime <span class="keyword">import</span> date,datetime</span><br><span class="line"><span class="comment">#__getattr__就是在查找不到的时候调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,birthday,info=&#123;&#125;)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthady = birthday</span><br><span class="line">        self.info = info</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.info[item]</span><br><span class="line">        <span class="comment"># return "not find attr"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 无条件的进入,能不重写就不重写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"gYQ"</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User(<span class="string">"GYQ"</span>, date(year=<span class="number">1999</span>, month=<span class="number">7</span>, day=<span class="number">21</span>),info=&#123;<span class="string">"company_name"</span>:<span class="string">"imooc"</span>&#125;)</span><br><span class="line">    <span class="comment"># print(user.age)</span></span><br><span class="line">    print(user.company_name)</span><br></pre></td></tr></table></figure>

<p><strong>属性描述符</strong>:我们可以定义一个属性去通过<strong>set</strong>和<strong>get</strong>的方法，判断这个属性是否是某个属性的子类，当我们强性质需要输入的是某个类型的时候，我们就可以进行判断，如果不是我们就可以抛出异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  datetime <span class="keyword">import</span> date,datetime</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">把至少实现了内置属性__set__()和__get__()方法的描述符称为数据描述符；</span></span><br><span class="line"><span class="string">把实现了除__set__()以外的方法的描述符称为非数据描述符。</span></span><br><span class="line"><span class="string">类属性 &gt; 数据描述符 &gt; 实例属性 &gt; 非数据描述符 &gt; 找不到的属性触发__getattr__()</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntField</span>:</span></span><br><span class="line">    <span class="comment"># 数据描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span>  self.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value,numbers.Integral):</span><br><span class="line">            <span class="keyword">raise</span>  ValueError(<span class="string">"int value need"</span>)</span><br><span class="line">        <span class="keyword">if</span> value&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"value must &gt;0"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDataIntField</span>:</span></span><br><span class="line"><span class="comment">#     非数据描述符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    age = IntField()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User()</span><br><span class="line">    user.age = <span class="number">1</span></span><br><span class="line">    print(user.age)</span><br></pre></td></tr></table></figure>

<p><strong><strong>new</strong>和<strong>init</strong>的区别</strong>:new 是用来控制对象的生成过程，在对象生成之前init 是用来完善对象的，添加属性，如果new方法不返回对象，则不会调用init函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="comment"># __new__可以自定义类的生成过程的的 传递的是cls是个类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"in new"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __init__传递的是一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        print(<span class="string">"in init"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user =User(name =<span class="string">"bobby"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3. 迭代器和生成器</strong><br><strong>Python中的迭代协议</strong>:什么是迭代器？：迭代器是访问集合内的一种方式，一遍用来遍历数据，迭代器和以下标的访问方式不一样，迭代器是不能返回的，迭代器提供了一种惰性访问的方式，同时迭代器是实现了<strong>iter</strong>方法和<strong>next</strong>方法。</p>
<p><strong>什么是迭代器和可迭代对象</strong>：<br>可迭代对象是实现了<strong>iter</strong>()方法的对象，而迭代器（Iterator）则是实现了<strong>iter</strong>()和<strong>next</strong>()方法的对象，可以显示地获取下一个元素。这种可以被next调用并不断返回下一个值的对象称为迭代器。<br>迭代器一定是可迭代对象，反过来则不一定成立。用iter()函数可以把list、dict、str等Iterable变成Iterator<br><strong>Python中的生成器函数的使用</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成器函数:函数里只要有yield关键字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fun</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 惰性求值，延迟求值提高了也能，内部不会消耗内存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fib</span><span class="params">(index)</span>:</span></span><br><span class="line">    n,a,b=<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&lt;index:</span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> b</span><br><span class="line">            a,b =b,a+b</span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fun1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">6</span></span><br><span class="line">    <span class="comment"># return会直接停止当生成器函数中含有return时，return不会返回任何值，会直接终止当前生成器，</span></span><br><span class="line">    <span class="comment"># 对yield的作用没有影响，当函数执行到return时候，</span></span><br><span class="line">    <span class="comment"># 调用next()来执行生成器则会报错，如果使用for循环遍历，for循环会自动捕获该异常，直接停止遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"imooc"</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 返回的是一个生成器对象,在Python字节码的时候就产生了</span></span><br><span class="line">    gen = gen_fun()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gen:</span><br><span class="line">        print(i)</span><br><span class="line">    print(<span class="string">'---------'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gen_fib(<span class="number">5</span>):</span><br><span class="line">        print(i)</span><br><span class="line">    print(<span class="string">'------'</span>)</span><br><span class="line">    a = gen_fun1()</span><br><span class="line">    print(a)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>

<p><strong>使用生成器读取大文件</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#500G, 特殊 一行</span></span><br><span class="line"><span class="comment"># 使用的是f.read方法，读的是4096个字节</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myreadlines</span><span class="params">(f, newline)</span>:</span></span><br><span class="line">  buf = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">while</span> newline <span class="keyword">in</span> buf:</span><br><span class="line">      pos = buf.index(newline)</span><br><span class="line">      <span class="keyword">yield</span> buf[:pos]</span><br><span class="line">      buf = buf[pos + len(newline):]</span><br><span class="line">    chunk = f.read(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">      <span class="comment">#说明已经读到了文件结尾</span></span><br><span class="line">      <span class="keyword">yield</span> buf</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    buf += chunk</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./input.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> myreadlines(f, <span class="string">"&#123;|&#125;"</span>):</span><br><span class="line">        <span class="keyword">print</span> (line)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>Python - 高级编程 - 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级编程基础（二）</title>
    <url>/2020/05/09/python-seniorbasic2/</url>
    <content><![CDATA[<p>好久没有更新个人的博客了，经过这几天的学习，对于Python的基础又有了新的认知，所以将要从以下几个方面来介绍-自定义序列类-深入python的set和dict这几个方面来介绍。</p>
<a id="more"></a>

<p><strong>1. 自定义序列类</strong></p>
<p><strong>Python中的序列分类</strong>：<br>容器序列：list、tuple、deque<br>扁平序列：str、bytes、bytearray、array.array<br>可变序列：list， deque，bytearray、array<br>不可变序列：str、tuple、bytes<br>容器序列和扁平序列的区别就是 容器序列可以放置任意类型的数据,扁平序列只能放置一致的数据类型<br>是的扁平序列的存储和读取速度也会更快，因为数据工整，所以如果是出于性能的考虑 能用扁平序列就用扁平序列</p>
<p><strong>Python的list中+ += extend append</strong>：<br>+：并不会覆盖原来的数值的值，而是会产生一个新的值并赋值，a=[1,2]，b=[3,4]，a+b=[1,2,3,4],原本的a与b都不会发生改变<br>+=：会对+=的值进行覆盖，a=[1,2]，b=[3,4]，a+=b，那么a的值是[1,2,3,4]，b的值不会发生改变，没有返回值<br>extend：extend的内部调用的就是+=的方法，没有返回值<br>append：append是往列表中添加一个元素，并且改变原数据的值a=[1,2]，b=[3,4]，a.append(b),a=[1,2,[3,4]]</p>
<p><strong>Python实现可切片的对象</strong>：<br>在Python中实现可切片的对象需要重构魔法函数的<strong>setitem</strong>方法例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span>:</span></span><br><span class="line"><span class="comment">#     支持切片操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,group_name,company_name,staffs)</span>:</span></span><br><span class="line">        self.group_name=group_name</span><br><span class="line">        self.company_name = company_name</span><br><span class="line">        self.staffs = staffs</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.staffs.reverse()</span><br><span class="line">    <span class="comment"># 可切片的关键</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># return self.staffs[item]</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> isinstance(item,slice):</span><br><span class="line">            <span class="keyword">return</span> cls(group_name=self.group_name,company_name=self.company_name,staffs=self.staffs[item])</span><br><span class="line">        <span class="keyword">elif</span> isinstance(item,numbers.Integral):</span><br><span class="line">            <span class="keyword">return</span> cls(group_name=self.group_name, company_name=self.company_name, staffs=[self.staffs[item]])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span>  len(self.staffs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.staffs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> self.staffs:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">staffs=[<span class="string">"bobby1"</span>,<span class="string">"bobby2"</span>,<span class="string">"bobby3"</span>,<span class="string">"bobby4"</span>,<span class="string">"bobby5"</span>,<span class="string">"bobby6"</span>,<span class="string">"bobby7"</span>]</span><br><span class="line">group = Group(company_name=<span class="string">"immoc"</span>,group_name=<span class="string">"user"</span>,staffs=staffs)</span><br><span class="line">sub_group = group[::<span class="number">2</span>]</span><br><span class="line">print(sub_group)</span><br></pre></td></tr></table></figure>

<p><strong>Python使用bisect来维护序列和使用二分查找的包</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="comment"># 用来处理已经排序好的序列，升序</span></span><br><span class="line"><span class="comment"># 二分查找</span></span><br><span class="line">inter_list=[]</span><br><span class="line">bisect.insort(inter_list,<span class="number">3</span>)</span><br><span class="line">bisect.insort(inter_list,<span class="number">2</span>)</span><br><span class="line">bisect.insort(inter_list,<span class="number">5</span>)</span><br><span class="line">bisect.insort(inter_list,<span class="number">6</span>)</span><br><span class="line">bisect.insort(inter_list,<span class="number">7</span>)</span><br><span class="line">print(inter_list)</span><br><span class="line">print(bisect.bisect(inter_list,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>Python中的闭包</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#闭包函数的实例</span></span><br><span class="line"><span class="comment"># outer是外部函数 a和b都是外函数的临时变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">( a )</span>:</span></span><br><span class="line">    b = <span class="number">10</span></span><br><span class="line">    <span class="comment"># inner是内函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment">#在内函数中 用到了外函数的临时变量</span></span><br><span class="line">        print(a+b)</span><br><span class="line">        <span class="comment"># 外函数的返回值是内函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 在这里我们调用外函数传入参数5</span></span><br><span class="line">    <span class="comment">#此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo</span></span><br><span class="line">    <span class="comment"># 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数</span></span><br><span class="line">    demo = outer(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量</span></span><br><span class="line">    <span class="comment"># demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数</span></span><br><span class="line">    demo()</span><br><span class="line">    demo2 = outer(<span class="number">7</span>)</span><br><span class="line">    demo2()</span><br></pre></td></tr></table></figure>

<p><strong>2. 深入python的set和dict</strong></p>
<p><strong>dict中的继承</strong>：dict继承自abc模块的MutableMapping<br><strong>dict中的子类</strong>：UserDict和defaultdict</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mydict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        super().__setitem__(key,value*<span class="number">2</span>)</span><br><span class="line">my_dict = Mydict(one=<span class="number">1</span>)</span><br><span class="line">my_dict[<span class="string">"one"</span>]=<span class="number">1</span></span><br><span class="line">print(my_dict)</span><br></pre></td></tr></table></figure>
<p>在重写的子类中修改<strong>setitem</strong>可以修改Key和value的值以达到dict中修改的目的</p>
<p><strong>Python中的列表使用情况</strong>：<br>set集合 frozenset(不可变集合)无序，不重复<br>dict查找的性能远大于list<br>list随着数据的增大，时间会增大<br>dict中查找元素不会随着dict的增大而增大<br>哈希表通过计算key的散列值来定位散列表中的一个表元、从而存放进去，可以理解为，key是表元，value是值，我们取值的时候，直接<br>访问key即可获取到value所以复杂度为O(1)，列表要挨个遍历时间复杂度最大为O(n)，所以dict更快。<br>然后判断表元是否为空，是的话抛出key Error异常，否的话判断键是否相等是的话返回列表的值，否的话重新定位</p>
<p>Python中可哈希的意思为不可变<br>如果一个对象在其生命周期内，其哈希值从未改变(这需要一个<strong>hash</strong>()方法)，<br>并且可以与其他对象进行比较(这需要一个<strong>eq</strong>()或<strong>cmp</strong>()方法)，<br>那么这个对象就是可哈希的。哈希对象的相等意味着其哈希值的相等。</p>
<p>1、所以可哈希的通常作为dict的key，自己实现的类要实现<strong>hash</strong><br>2、dict的内存花销大，自定义的对象或者Python内部的对象都是用dict包装的<br>3、dict的存储顺序和元素添加顺序油管<br>4、添加数据有可能改变已有数据的顺序，当内存空间不够的时候，进行扩展，所以可能改变顺序</p>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>Python - 高级编程 - 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级编程基础（一）</title>
    <url>/2020/05/05/python-seniorbasic1/</url>
    <content><![CDATA[<p>好久没有更新个人的博客了，经过这几天的学习，对于Python的基础又有了新的认知，所以将要从以下几个方面来介绍-python中一切皆对象-魔法函数-类和对象-这几个方面来介绍。</p>
<a id="more"></a>
<h3 id="一、Python中一切皆对象"><a href="#一、Python中一切皆对象" class="headerlink" title="一、Python中一切皆对象"></a>一、Python中一切皆对象</h3><p><strong>1. 万物皆对象</strong></p>
<p>在Python中一切属性都是可以是对象，函数是对象，类也是对象，我们经常说面向对象编程，JAVA是面向对象，Python也是面向对象，因此静态语言与动态语言的一个区别就出来了那就是：Python中的面向对象更为彻底，我们可以来看下面的这一段代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask</span><span class="params">(name =<span class="string">"GYQ"</span>)</span>:</span></span><br><span class="line">    print(name)</span><br><span class="line">my_func =ask</span><br><span class="line">my_func(<span class="string">"GYQQ"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"高永奇"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ab1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"aaaa"</span>)</span><br><span class="line">my_class = Person</span><br><span class="line">my_class().ab1()</span><br><span class="line">my_class1=Person()</span><br><span class="line">my_class1.ab1()</span><br></pre></td></tr></table></figure>
<p><strong>万物皆对象的原因解释</strong>：在以上的代码中我们构建了一个函数ask，同时我们申明了一个my_func–&gt;ask那么我们在使用my_func的时候其实是构建了一个对象，而这个对象的底层其实是调用的ask里的内置方法，同样对于my_class对象，my_class–&gt;Person–&gt;类方法。<br><strong>另一层的知识点</strong>:在调用函数的时候如果加上（），那么我们是调用函数同时获得返回值，不如果不加（），只是调用该函数。而在类中如果并不加（），其实是两个值之间的关联联系（赋值），比如my_class–&gt;Person，my_class自身就是把Person的值赋值给自己。所以在调用ab1方法的时候就需要使用my_class().ab1()的形式了，而类中加上（），其实就是将Peroson这个类对象给my_class1，所以可以直接调用ab1的类方法。</p>
<p><strong>2. Type、Object、Class的关系</strong></p>
<p>首先我们先来看以一下以下的关联图来解说继承与实例之间的关系<br><img src="/2020/05/05/python-seniorbasic1/%E5%9B%BE%E7%89%871.png" alt></p>
<p>在Python中所有实例化的最高级别是type，所有属性的最高基类都是object。我们看以下的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(type(list))</span><br><span class="line">print(list.__bases__)</span><br><span class="line">print(type(type))</span><br><span class="line">print(type(object))</span><br><span class="line">print(type.__bases__)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">st = Student()</span><br><span class="line">print(type(st.__class__))</span><br><span class="line">print(isinstance(st,object))</span><br></pre></td></tr></table></figure>
<p>其中list的基类是object，st的基类是Student,Student的基类就是object，所以isinstance(st,object)的结果True。同时type的实例化对象是object，object的实例化对象是type，type的基类是objct。<strong>class</strong>上一个父类，如果你仔细的理解一下上面的图就很容易明白这个关系。</p>
<p><strong>3. Python中的内置类型</strong></p>
<p>首先我们来说下对象的三个特征，身份、类型、值。同时None的值是只有一个的。可以在Python中输入以下的代码，它的id值，也就是地址永远是一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">None</span></span><br><span class="line">print(type(a))</span><br><span class="line">print(id(<span class="literal">None</span>))</span><br><span class="line">print(id(<span class="literal">None</span>))</span><br></pre></td></tr></table></figure>
<p>身份是a，类型是NoneType，值是None，所以对象的三个特征就是身份、类型、值。数值的类型分别有：int，float，complex（复数），bool。序列类型：list，bytes、bytearray、memoryview（二进制序列），range，tuple，str，array。上下文管理器：with</p>
<h3 id="二、Python中的魔法函数"><a href="#二、Python中的魔法函数" class="headerlink" title="二、Python中的魔法函数"></a>二、Python中的魔法函数</h3><p><strong>1. 什么是魔法函数</strong></p>
<p>python内置的以双下划线开头并以双下划线结尾的函数，不能自己定义只能使用python给予的这样的一个函数叫做魔法函数。</p>
<p><strong>2. 魔法函数的介绍</strong></p>
<p>在使用len方法与repr的时候就需要该对象中必须实现了<strong>len</strong>方法与<strong>repr</strong>方法例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,employee_list)</span>:</span></span><br><span class="line">        self.employee = employee_list</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">","</span>.join(self.employee)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"调用__repr__方法"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abd</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"----"</span>)</span><br><span class="line">com = Company([<span class="string">"tom"</span>,<span class="string">"bob"</span>])</span><br><span class="line">print(len(com))</span><br><span class="line">print(repr(com))</span><br></pre></td></tr></table></figure>
<p>那么上述代码的输出结果就是3与调用<strong>repr</strong>方法，因此我们可以发现在Python中实现了内置的函数，可以实现内置的方法，同时这些方法是Python中给予的。不能由自己定义的。</p>
<h3 id="三、Python中的类和对象"><a href="#三、Python中的类和对象" class="headerlink" title="三、Python中的类和对象"></a>三、Python中的类和对象</h3><p><strong>1. 面向对象的三大特性</strong></p>
<p>面向对象的三大特性：封装，继承和多态<br><strong>封装</strong>：在类的内部定义属性和方法，通过对象或类名来访问属性和方法，隐藏功能的实现细节，也可以设置访问权限。<br>广义的封装：实例化一个对象，给对象空间封装一些属性；狭义的封装：私有制；私有成员：私有静态字段，私有方法，私有对象属性<br><strong>继承</strong>：子类需要重用父类的属性和方法，子类中也可以定义自己的属性和方法。<br><strong>多态</strong>：python是弱类型语言，python中处处是多态；<br><strong>2. 什么是鸭子类型</strong><br>python中没有多态，但是有鸭子类型  ==》一些类含有相同的方法，则这些类就互称为鸭子<br><strong>静态语言 vs 动态语言</strong><br>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<br>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了。<br>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。<br>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。<br><strong>3. 抽象基类abc模块</strong><br>“抽象基类”这个词可能听着比较”深奥”,其实”基类”就是”父类”,”抽象”就是”假”的意思,”抽象基类”就是”假父类.”，使用抽象基类的原因就是因为构建类的时候，我们需要像鸭子类型一样去实现某些方法，要求我们的子类必须重构父类中的某些方法，所以我们可以使用@abc.abstractmethod的形式强制子类实现某些方法例如以下的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheBase</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,key)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self,key,value)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>4. isinstance与type的区别</strong></p>
<p>isinstance判断实例的对象会根据nro法则不断的往上寻找，而type只会寻找上一层的。</p>
<p><strong>5. 类变量和实例变量</strong></p>
<p>1.类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；<br>2.类体中，所以函数内部：以“self.变量名”的方式定义的变量，称为实例属性或实例变量；<br>3.类体中，所有函数内部：以“变量名=变量值”的方式定义的变量，称为局部变量。<br>4.类变量可以修改而实例变量不可以修改<br>5.类变量在类调用的时候可以叠加和改变，而实例变量不会<br>根据以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="comment"># 类变量，所有实例共享的</span></span><br><span class="line">    aa = <span class="number">1</span></span><br><span class="line">    <span class="comment"># self是类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        self.x  = x</span><br><span class="line">        self.y  = y</span><br><span class="line">a = A(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">A.aa=<span class="number">11</span></span><br><span class="line"><span class="comment"># 如果我们使用实例的类修改方法的话，不会修改类变量里的值，而是会新建一个实例a的变量，把属性aa放进去</span></span><br><span class="line"><span class="comment"># 如果我们使用的是A的话进行修改会修改A的变量</span></span><br><span class="line">a.aa =<span class="number">100</span></span><br><span class="line">a.x =<span class="number">5</span></span><br><span class="line">print(a.x,a.y,a.aa)</span><br><span class="line">print(A.aa)</span><br></pre></td></tr></table></figure>
<p>所以类变量会被修改而实例变量则不会。</p>
<p><strong>6. 类的查找顺序-mro查找</strong></p>
<p>在Python中子类的继承关系是根据mro查找方法来定的，算法内容太过负责只是在此提一下，如果需要可以百度该方法。</p>
<p><strong>7. 类方法、静态方法和实例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,year,month,day)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br><span class="line">        self.day = day</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tomorrow</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.day +=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_from_string</span><span class="params">(date_str)</span>:</span></span><br><span class="line">        year, month, day = tuple(date_str.split(<span class="string">'-'</span>))</span><br><span class="line">        <span class="keyword">return</span> Date(int(year),int(month),int(day))</span><br><span class="line">    <span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls,date_str)</span>:</span></span><br><span class="line">        year, month, day = tuple(date_str.split(<span class="string">'-'</span>))</span><br><span class="line">        <span class="keyword">return</span> cls(int(year),int(month),int(day))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;/&#123;&#125;/&#123;&#125;"</span>.format(self.year,self.month,self.day)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    new_day = Date(<span class="number">2020</span>,<span class="number">3</span>,<span class="number">23</span>)</span><br><span class="line">    print(new_day)</span><br><span class="line">    new_day.tomorrow()</span><br><span class="line">    print(new_day.day)</span><br><span class="line">    print(new_day)</span><br><span class="line">    date_str=<span class="string">"2020-3-23"</span></span><br><span class="line">    year,month,day = tuple(date_str.split(<span class="string">'-'</span>))</span><br><span class="line">    new_day =Date(int(year),int(month),int(day))</span><br><span class="line">    print(new_day)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用staticmethod完成初始化</span></span><br><span class="line">    new_day =Date.parse_from_string(date_str)</span><br><span class="line">    print(new_day)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用classmethod完成初始化</span></span><br><span class="line">    new_day =Date.from_string(date_str)</span><br><span class="line">    print(new_day)</span><br></pre></td></tr></table></figure>
<p>使用场景总结：<br>1.实例方法，静态方法，类方法三者中除了实例方法被类调用时要将实例化对象传递给 self外，另外两个都可以直接用类或者是类的实例化对象调用。<br>2.类方法和静态方法主要用于不创建实例化对象的情况下，因为如果每次调用类中的方法时都创建实例化对象，会对系统造成很大的压力，造成系统资源浪费<br>3.实例方法第一个参数为self，静态方法与类无关联，类方法第一个参数为cls，相当于将类当做对象进行了传递</p>
<p><strong>8. Python中的私有属性</strong></p>
<p>其实在Python中是没有私有属性这个概念的但是为了引入这样一个概念，我们默认使用__表示私有属性，例如以下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line">    <span class="comment"># __表示私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,birthday)</span>:</span></span><br><span class="line">        self.__birthday = birthday</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回年龄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2020</span>-self.__birthday</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = User(<span class="number">1999</span>)</span><br><span class="line">    print(user.__birthday)</span><br><span class="line">    print(user._User__birthday)</span><br><span class="line">    print(user.get_age())</span><br></pre></td></tr></table></figure>
<p>那么使用的过程中如果使用user.<strong>birthday的话是不会获得值得，而是要使用_User后再调用</strong>birthday才可以获得到值</p>
<p><strong>9. Python中的自省机制</strong></p>
<p>在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力。<br>说的更简单直白一点：自省就是面向对象的语言所写的程序在运行时，能够知道对象的类型。简单一句就是，运行时能够获知对象的类型。在Python中可以通过<strong>dict</strong>查询属性,同时也可以进行类中的添加。</p>
<p><strong>10. Python中的super函数</strong></p>
<p>super出现的最主要的原因就是为了更方便的使用父类中的方法，实现代码的重用的问题，那么super真的是继承父类吗？其实不然，super只是为了能使用父类中的方法而不需要重构。那么super到底执行顺序是什么样的？其实本身就是mro算法的顺序，先执行子类过后再执行父类。</p>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>Python - 高级编程 - 基础</tag>
      </tags>
  </entry>
  <entry>
    <title>WebScraper</title>
    <url>/2020/03/23/WebScraper/</url>
    <content><![CDATA[<p>这里给大家推荐一个非常好用的谷歌爬虫得插件叫做WebScraper，这是一款可以用于爬取规则网站的工具，本篇文章将会对WebScraper的安装与操作等多个方面对其进行介绍。你可以不需要知道爬虫的知识点，爬虫的代码撰写，就可以爬取较为规则的网站。</p>
<a id="more"></a>
<h3 id="一、安装说明"><a href="#一、安装说明" class="headerlink" title="一、安装说明"></a>一、安装说明</h3><p>首先我们需要安装Chrome浏览器，打开谷歌的应用去安装WebScraper，当然需要科学上网才可能完成。如果，确实没有科学上网的话，推荐大家安装一款名叫&lt;&lt;极速浏览器&gt;&gt;的浏览器，该款浏览器是具备了谷歌里的内核系统，同时可以下载谷歌里的插件。<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%871.png" alt><br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%872.png" alt></p>
<h3 id="二、演示实例"><a href="#二、演示实例" class="headerlink" title="二、演示实例"></a>二、演示实例</h3><ul>
<li><ol>
<li>网站选择与设置<br>本文用爬取缤客的酒店信息作为演示，百度搜索缤客的页面<a href="https://www.booking.com/" target="_blank" rel="noopener">https://www.booking.com/</a>目的地我们可以选择成都。对于kin缤客的网站我们是需要设置入住日期的，同时为了减小爬取的量我们选择离市中心5公里内的。<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%873.png" alt></li>
</ol>
</li>
<li><ol start="2">
<li>WebScraper创建<br>按住F12，选择WebScraper中的Create Sitemap<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%874.png" alt><br>创建Sitemap name和Start URL<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%875.png" alt></li>
</ol>
</li>
<li><ol start="3">
<li>WebScraper属性创建<br>选择Add new selector，Type选择Element click，Id我们输入Info Element,Selector选择每一个属性实例图如下：（其中Type Element click的意思是选择每一个属性块，并且可以进行点击翻页；Element scroll down的意思是选择每一个属性快，并且可以进行下滑;Text为内容；Link为链接）<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%876.png" alt><br>选择Click selector中的Select，选择页底的页面翻译，从而进行翻页<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%877.png" alt><br>勾选Multiple，设置Delay (ms)为200<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%878.png" alt><br>创建成功！</li>
</ol>
</li>
<li><ol start="4">
<li>WebScraper单个属性创建<br>选择酒店的名称<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%879.png" alt><br>选择价格<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%8710.png" alt><br>选择评分<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%8711.png" alt></li>
</ol>
</li>
<li><ol start="5">
<li>WebScraper完成爬取<br>选择Sitemap binkeinfo中的scrape，开始爬取<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%8712.png" alt><br>爬取开始<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%8713.png" alt><br>数据获取完成<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%8714.png" alt><br>选择Sitemap binkeinfo中的Export data as csv导出成为csv模式<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%8715.png" alt><br>数据内容如下，完成爬取<br><img src="/2020/03/23/WebScraper/%E5%9B%BE%E7%89%8716.png" alt></li>
</ol>
</li>
</ul>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>本文所讲内容有限，并不能全部细讲，只能讲述一个案例来说明WebScraper的功能，如果想更深入的学习Scraper工具可以搜索<a href="https://search.bilibili.com/all?keyword=web%20scraper" target="_blank" rel="noopener">https://search.bilibili.com/all?keyword=web%20scraper</a>内的内容进行深入的学习。转载请注明出处，禁止一切商业用途，目的：仅供学习。欢迎各位大佬指正错误，有问题请在下方留言，或者点击左边的微信/QQ加我进行联系。看到后会第一时间进行回复。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python爬虫实现翻译功能</title>
    <url>/2020/03/02/Pachong_Fanyi/</url>
    <content><![CDATA[<p>写这篇文档的主要初衷是因为：因为前几天的美赛，由于我们要通过评论的内容找到该评论的情感倾向，但是由于Excel内的翻译功能支持不了大规模的数据进行翻译，然后其他的一些在线翻译的软件需要付费，所以自己写了一个端口用于翻译。（本篇文章内容的翻译仅支持小规模数据，做到及翻及储，大规模数模进行多次翻译还是会出现无连接的情况）</p>
<a id="more"></a>
<h3 id="一、文章说明"><a href="#一、文章说明" class="headerlink" title="一、文章说明"></a>一、文章说明</h3><p>一开始在Github上找能对Excel进行翻译的时候发现了一篇通过爬虫实现翻译的源码，然而我并没有看里面的内容，就直接进行运行，导致因为访问频率过快导致直接被谷歌直接封掉了端口，所以以下的内容都是基于<strong>有道翻译</strong>    的翻译进行端口的实现。（非常感谢我某位朋友给我找的Github上的源码使得我比赛期间的谷歌端口一直不能使用）</p>
<h3 id="二、端口分析"><a href="#二、端口分析" class="headerlink" title="二、端口分析"></a>二、端口分析</h3><ul>
<li><ol>
<li>首先我们先打开有道翻译的界面，按住F12（建议使用谷歌浏览器），选择XHR<br><img src="/2020/03/02/Pachong_Fanyi/%E5%9B%BE%E7%89%871.png" alt></li>
</ol>
</li>
<li><ol start="2">
<li>在请输入你要翻译的文字或网址内输入要翻译的内容<br><img src="/2020/03/02/Pachong_Fanyi/%E5%9B%BE%E7%89%872.png" alt></li>
</ol>
</li>
<li><ol start="3">
<li>分析网址与请求<br>其中请求的网址为：<a href="http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule，我们可以发现其中的smartresult=dict这一段话才是传输的数据，并且数据是以dict的方式进行存储并传输过去的。" target="_blank" rel="noopener">http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule，我们可以发现其中的smartresult=dict这一段话才是传输的数据，并且数据是以dict的方式进行存储并传输过去的。</a><br><img src="/2020/03/02/Pachong_Fanyi/%E5%9B%BE%E7%89%873.png" alt></li>
</ol>
</li>
<li><ol start="4">
<li>分析FromData的表单格式<br>我们可以发现表单中的i对应的key的值就是我们输入的翻译的内容<br><img src="/2020/03/02/Pachong_Fanyi/%E5%9B%BE%E7%89%874.png" alt><h3 id="三、代码的撰写"><a href="#三、代码的撰写" class="headerlink" title="三、代码的撰写"></a>三、代码的撰写</h3></li>
</ol>
</li>
<li><ol>
<li>首先要导入代码的必要请求头<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>构造请求头<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fanyi</span><span class="params">(key)</span>:</span></span><br><span class="line">    url =  <span class="string">"http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule"</span></span><br><span class="line">    agent1 = <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36"</span></span><br><span class="line">    agent2 = <span class="string">"Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3"</span></span><br><span class="line">    agent3 = <span class="string">"Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0"</span></span><br><span class="line">    agent4 = <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727"</span></span><br><span class="line">    agent_list = [agent1,agent2,agent3,agent4]</span><br><span class="line">    agent = random.choice(agent_list)</span><br><span class="line">    header = &#123;<span class="string">"User-Agent"</span>:agent&#125;</span><br><span class="line">    <span class="comment"># post请求需要提交的数据</span></span><br><span class="line">    formdata = &#123;</span><br><span class="line">        <span class="string">"i"</span>: key,</span><br><span class="line">        <span class="string">"from"</span>: <span class="string">"AUTO"</span>,</span><br><span class="line">        <span class="string">"to"</span>: <span class="string">"AUTO"</span>,</span><br><span class="line">        <span class="string">"smartresult"</span>: <span class="string">"dict"</span>,</span><br><span class="line">        <span class="string">"client"</span>: <span class="string">"fanyideskweb"</span>,</span><br><span class="line">        <span class="string">"salt"</span>: <span class="string">"15695898180107"</span>,</span><br><span class="line">        <span class="string">"sign"</span>: <span class="string">"bf4bfe3da1f8eb780b6f45cfd226e3e0"</span>,</span><br><span class="line">        <span class="string">"ts"</span>: <span class="string">"1569589818010"</span>,</span><br><span class="line">        <span class="string">"bv"</span>: <span class="string">"97ba7c7fb78632ae9b11dcf6be726aee"</span>,</span><br><span class="line">        <span class="string">"doctype"</span>: <span class="string">"json"</span>,</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"2.1"</span>,</span><br><span class="line">        <span class="string">"keyfrom"</span>: <span class="string">"fanyi.web"</span>,</span><br><span class="line">        <span class="string">"action"</span>: <span class="string">"FY_BY_REALTlME"</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="3">
<li>发送Post请求并用re表达式提取信息<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.post(url=url,headers = header,data=formdata).content.decode()</span><br><span class="line"><span class="comment"># "tgt":"hello"</span></span><br><span class="line">pat1=re.compile(<span class="string">'"tgt":"(.*?)"'</span>)</span><br><span class="line">data = pat1.findall(response)</span><br><span class="line">str1=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    str1+=i</span><br><span class="line"><span class="keyword">return</span> str1</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li>本篇文章使用的数据说明<br><img src="/2020/03/02/Pachong_Fanyi/%E5%9B%BE%E7%89%875.png" alt><br>我们主要是进行翻译review_headline和review_body的这两列信息，同时本篇文章的数据是用UTF-8 模式进行保存的csv数据。并且由于一段时间内可能存在无连接请求的可能加入了时间间隔为1s，由于可能出现一端无连接的情况，都是在翻译完成以后立刻进行保存。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = pd.read_csv(<span class="string">"./microwave.csv"</span>, encoding=<span class="string">'UTF-8'</span>, error_bad_lines=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data.review_headline:</span><br><span class="line">        info = fanyi(i)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"./microwave.txt"</span>,<span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(str(info)+<span class="string">'\n'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="四、代码合集"><a href="#四、代码合集" class="headerlink" title="四、代码合集"></a>四、代码合集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fanyi</span><span class="params">(key)</span>:</span></span><br><span class="line">    url =  <span class="string">"http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule"</span></span><br><span class="line">    agent1 = <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36"</span></span><br><span class="line">    agent2 = <span class="string">"Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3"</span></span><br><span class="line">    agent3 = <span class="string">"Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0"</span></span><br><span class="line">    agent4 = <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727"</span></span><br><span class="line">    agent_list = [agent1,agent2,agent3,agent4]</span><br><span class="line">    agent = random.choice(agent_list)</span><br><span class="line">    header = &#123;<span class="string">"User-Agent"</span>:agent&#125;</span><br><span class="line">    <span class="comment"># post请求需要提交的数据</span></span><br><span class="line">    formdata = &#123;</span><br><span class="line">        <span class="string">"i"</span>: key,</span><br><span class="line">        <span class="string">"from"</span>: <span class="string">"AUTO"</span>,</span><br><span class="line">        <span class="string">"to"</span>: <span class="string">"AUTO"</span>,</span><br><span class="line">        <span class="string">"smartresult"</span>: <span class="string">"dict"</span>,</span><br><span class="line">        <span class="string">"client"</span>: <span class="string">"fanyideskweb"</span>,</span><br><span class="line">        <span class="string">"salt"</span>: <span class="string">"15695898180107"</span>,</span><br><span class="line">        <span class="string">"sign"</span>: <span class="string">"bf4bfe3da1f8eb780b6f45cfd226e3e0"</span>,</span><br><span class="line">        <span class="string">"ts"</span>: <span class="string">"1569589818010"</span>,</span><br><span class="line">        <span class="string">"bv"</span>: <span class="string">"97ba7c7fb78632ae9b11dcf6be726aee"</span>,</span><br><span class="line">        <span class="string">"doctype"</span>: <span class="string">"json"</span>,</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"2.1"</span>,</span><br><span class="line">        <span class="string">"keyfrom"</span>: <span class="string">"fanyi.web"</span>,</span><br><span class="line">        <span class="string">"action"</span>: <span class="string">"FY_BY_REALTlME"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.post(url=url,headers = header,data=formdata).content.decode()</span><br><span class="line">    <span class="comment"># "tgt":"hello"</span></span><br><span class="line">    pat1=re.compile(<span class="string">'"tgt":"(.*?)"'</span>)</span><br><span class="line">    data = pat1.findall(response)</span><br><span class="line">    str1=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        str1+=i</span><br><span class="line">    <span class="keyword">return</span> str1</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = pd.read_csv(<span class="string">"./microwave.csv"</span>, encoding=<span class="string">'UTF-8'</span>, error_bad_lines=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data.review_headline:</span><br><span class="line">        info = fanyi(i)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"./microwave.txt"</span>,<span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(str(info)+<span class="string">'\n'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>输出的数据如下<br><img src="/2020/03/02/Pachong_Fanyi/%E5%9B%BE%E7%89%876.png" alt></li>
</ul>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>转载请注明出处，禁止一切商业用途，目的：仅供学习与使用翻译端口没有任何其他目的。欢迎各位大佬指正错误，有问题请在下方留言，或者点击左边的微信/QQ加我进行联系。看到后会第一时间进行回复。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>端口</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Git+GitHub+TortoiseGit间的操作使用</title>
    <url>/2020/03/02/Github_Wugui/</url>
    <content><![CDATA[<p>近几次发现很多人在使用Git的过程中是通过使用Git的命令进行文件的上传与下载的，所以，就想在这里推荐一款集成了Git命令的图形化软件，从而省下敲命令与思考的时间，更加人性化的图形界面更方便进行操作。个人认为重复的过程是不需要一直重复进行操作的，利用节省下来的时间做更多的事情不是更好吗？本文对TortoiseGit的常用功能进行了叙述与演示。</p>
<a id="more"></a>
<p>下面是本文共享出来的安装链接：<a href="https://pan.baidu.com/s/1ek8Uc64-hMU74WkAJ7SI4Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ek8Uc64-hMU74WkAJ7SI4Q</a> 提取码：6omn</p>
<h2 id="1-Git与SVN的区别"><a href="#1-Git与SVN的区别" class="headerlink" title="1. Git与SVN的区别"></a>1. Git与SVN的区别</h2><ul>
<li><ol>
<li><strong>SVN</strong></li>
</ol>
</li>
<li><strong>SVN</strong>是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就郁闷了。而SVN的缺点也是很明显的，如果服务器单点故障那么就太恼火了瞬间就感觉要GG了，所以容错性差。</li>
<li><ol start="2">
<li><strong>Git</strong></li>
</ol>
</li>
<li><strong>Git</strong>是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。下图是Git的工作流程<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%871.png" alt></li>
</ul>
<h2 id="2-TortoiseGit的使用"><a href="#2-TortoiseGit的使用" class="headerlink" title="2. TortoiseGit的使用"></a>2. TortoiseGit的使用</h2><ul>
<li><ol>
<li>TortoiseGit的安装<br>本篇文章不重点讲TortoiseGit的安装了，在上面已经分享过了安装包，直接进行傻瓜式安装就可以了，但是在那之前一定要下载Git，如果出现什么问题的话可以直接进行百度，TortoiseGit是非常优秀的开源的版本库客户端，如果熟练使用的话可以节约很多的时间。</li>
</ol>
</li>
<li><ol start="2">
<li>创建版本库<br>在Git中我们可以直接在当前目录下运行Git Bash Here使用git init进行创建，而在TortoiseGit中也是非常的好用，首先我们现在目录下创一个文件test。<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%872.png" alt><br>然后进入文件夹，在空列表中点击右键Git在这里创建版本库，然后就会出现.git文件<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%873.png" alt><br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%874.png" alt></li>
</ol>
</li>
<li><ol start="3">
<li>文件提交至本地库<br>我们先创建创建一个测试的txt文件，然后右键点击选中TortoiseGit点击添加，之后成功添加。鼠标选中选择提交，在日至文件中输入修改的内容（必须填写），然后成功提交<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%875.png" alt><br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%876.png" alt><br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%877.png" alt></li>
</ol>
</li>
<li><ol start="4">
<li>文件修改、查看修改历史、差异比较<br>我们对txt里面的内容进行修改后txt文件左边会出现感叹号，也就是说明我们已经与本地仓库里的文件内容不同了所以，我们再次重新的重复3的过程，将新的文件推送进本地仓库内。填写日志信息，进行提交。<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%878.png" alt><br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%879.png" alt><br>选择txt文件选择显示日志信息<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8710.png" alt><br>选择txt文件选择与上一版进行比较<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8711.png" alt><br>选择txt文件选择显示日志信息，选择以前要变更的信息，右键重置到这个版本，打开更新后的文件会发现已经没有更新到前面的版本了<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8712.png" alt></li>
</ol>
</li>
<li><ol start="5">
<li>删除文件与还原文件<br>选择要删除的内容右键选择删除，至此本地仓库中没有了文件<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8713.png" alt><br>右键选择TortoiseGit-&gt;还原<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8714.png" alt></li>
</ol>
</li>
</ul>
<h2 id="3-TortoiseGit与Github结合使用"><a href="#3-TortoiseGit与Github结合使用" class="headerlink" title="3.TortoiseGit与Github结合使用"></a>3.TortoiseGit与Github结合使用</h2><p><strong>TortoiseGit的推送</strong></p>
<ul>
<li><ol>
<li>TortoiseGit的本地仓库的导入<br>首先你需要在Github上创建仓库，然后获得到HTTPS或者SSH，例如是使用的HTTPS的仓库为<a href="https://github.com/GaoBaiiBai/Algorithm-learning-content.git" target="_blank" rel="noopener">https://github.com/GaoBaiiBai/Algorithm-learning-content.git</a>，然后我们将本地仓库里添加两个要上传的代码文件夹<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8715.png" alt></li>
</ol>
</li>
<li><ol start="2">
<li>TortoiseGit与Github的连接<br>我们可以在文件夹内选择同步然后设置远端，这里我使用的是HTTPS进行的演示，如果你要是用SSH就直接生成密钥的时候设置进Putty密钥即可。<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8716.png" alt><br>至此我们已经与远程仓库之间构建了联系</li>
</ol>
</li>
<li><ol start="3">
<li>TortoiseGit推送至Github<br>在文件夹中右键选择Git同步<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8717.png" alt><br>在传输的过程中如果是使用HTTPS的只要输入自己的Github的账号和密码即可。<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8718.png" alt><br>这样一来即推送成功了！<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8719.png" alt></li>
</ol>
</li>
</ul>
<p><strong>TortoiseGit的拉取</strong><br>直接在Git中选中TortoiseGit，拉取-&gt;选择需要拉取的内容是分支或者是主支<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8720.png" alt></p>
<p><strong>TortoiseGit的克隆</strong><br>如果想直接clone别人Github上的文件，先创建一个文件夹，右键选择Git克隆<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8721.png" alt><br>输入相应的url<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8722.png" alt><br>fork成功<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8723.png" alt></p>
<p><strong>使用TortoiseGit实现分支管理</strong></p>
<ul>
<li><ol>
<li>分支的创建<br>右键选择TortoiseGit-&gt;创建分支-&gt;输入分支名字<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8724.png" alt><br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8725.png" alt></li>
</ol>
</li>
<li><ol start="2">
<li>分支的合并<br>右键选择TortoiseGit-&gt;分支合并-&gt;选择分支<br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8726.png" alt><br><img src="/2020/03/02/Github_Wugui/%E5%9B%BE%E7%89%8727.png" alt></li>
</ol>
</li>
<li><ol start="3">
<li>备注<br>两个分支中编辑的内容都是相互独立互不干扰的，那么如果在两个分支中都对同一个文件进行编辑，然后再合并，就有可能会出现冲突。要先对一个文件进行编辑过后提交至版本库，再对另一个文件进行编辑提交至版本库，最后进行分支合并，出现版本冲突，冲突需要手动解决。在冲突文件上单机右键选择“解决冲突”菜单项，再进行提交即可。</li>
</ol>
</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>TortoiseGit的使用还有很多，本文只是较为重点的功能进行了说明，当有其他需求的时候可以右键查看TortoiseGit图形工具，因为是图形化的界面有些功能就可以直接看见，非常方便。最后：转载请注明出处，禁止一切商业用途，目的：仅供学习，欢迎各位大佬指正错误，有问题请在下方留言，或者点击左边的微信/QQ加我进行联系。看到后会第一时间进行回复。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Git</tag>
        <tag>TortoiseGit</tag>
      </tags>
  </entry>
</search>
